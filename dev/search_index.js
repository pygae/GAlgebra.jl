var documenterSearchIndex = {"docs":
[{"location":"api/#GAlgebra.jl-API","page":"API","title":"GAlgebra.jl API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [GAlgebra]\nPages = [\"ga.jl\"]","category":"page"},{"location":"api/#GAlgebra.G-Tuple{Integer, Integer, Integer}","page":"API","title":"GAlgebra.G","text":"G(p::Integer, q::Integer, r::Integer)\n\nA convenient method to instantiate a Geometric Algebra with p positive, q negative and r zero dimensions.\n\nq and r defaults to zero if omitted.\n\nThe basis will be named with prefix e and indexed starting from 1.\n\nFor example:\n\n# Basic \nHyper   = G(1)       # Hyperbolic numbers. \nℂ       = G(0,1)     # Complex numbers.\nDual    = G(0,0,1)   # Dual numbers.\nℍ       = G(0,2)     # Quaternions.\n\n# Clifford\nCl2 =       G(2)     # Clifford algebra for 2D vector space.\nCl3 =       G(3)     # Clifford algebra for 3D vector space.\nSpacetime = G(1,3)   # Clifford algebra for timespace vectors.\n\n# Geometric\nPGA2D = G(2,0,1)     # Projective Euclidean 2D plane. (dual)\nPGA3D = G(3,0,1)     # Projective Euclidean 3D space. (dual)\nCGA2D = G(3,1)       # conformal 2D space. \nCGA3D = G(4,1)       # Conformal 3D space. \n\n# High-Dimensional GA\nDCGA3D = G(6,2)      # Double Conformal 3D Space.\nTCGA3D = G(9,3)      # Tripple Conformal 3D Space.\nDCGSTA = G(4,8)      # Double Conformal Geometric Space Time Algebra.\nQCGA   = G(9,6)      # Quadric Conformal Geometric Algebra.  \n\nTo instantiate a Geometric Algebra with more parameters, use galgebra.ga.Ga instead.\n\nFor example:\n\nimport SymPy: sympy\nusing GAlgebra\n\nGa = galgebra.ga.Ga\n\ng3d = Ga(\"e*x|y|z\")\n\n(r, th, phi) = coords = sympy.symbols(\"r theta phi\")\ns3d = Ga(\"e_r e_theta e_phi\", g=[1 0 0; 0 r^2 0; 0 0 r^2 * sympy.sin(th)^2], coords=coords, norm=true)\n(er, eth, ephi) = s3d.mv()\n\nPlease also consult the documentation of GAlgebra.\n\n\n\n\n\n","category":"method"},{"location":"api/#class-Mv","page":"API","title":"class Mv","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [GAlgebra]\nPages = [\"mv.jl\"]","category":"page"},{"location":"api/#GAlgebra.Mv","page":"API","title":"GAlgebra.Mv","text":"A wrapper class for galgebra.mv.Mv:\n\nall methods of galgebra.mv.Mv are delegated and can be called like in Python.\nenhanced with operator overriding and extra methods.\nautomatically supports pretty printing like in Python.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:*-Tuple{Mv, Mv}","page":"API","title":"Base.:*","text":"Geometric product.\n\nA * B equiv A B.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:+-Tuple{Mv, Mv}","page":"API","title":"Base.:+","text":"Addition.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:--Tuple{Mv, Mv}","page":"API","title":"Base.:-","text":"Subtraction.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:--Tuple{Mv}","page":"API","title":"Base.:-","text":"Unary negation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:/-Tuple{Mv, Mv}","page":"API","title":"Base.:/","text":"Division.\n\nA  B equiv A B^-1. Only valid when B has inverse.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:==-Tuple{Mv, Mv}","page":"API","title":"Base.:==","text":"Comparisons of equality.\n\nA = B equiv mathrmsimplify(A - B) = 0\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:~-Tuple{Mv}","page":"API","title":"Base.:~","text":"Reversion.\n\n~A = A[:~] = rev(A) = A.rev() equiv tildeA equiv A^dagger\n\nIn literature the notation is usually tildeA or A^dagger, the former is illegal syntax and \\dagger in the latter is is reserved by Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.adjoint-Tuple{Mv}","page":"API","title":"Base.adjoint","text":"Dual, i.e. orthogonal complement, Lambda^p to Lambda^n-p.\n\nA' equiv A^bot equiv A I\n\nNote: call Ga.dual_mode(mode) to globally specify a different dual mode (I+ is the default):\n\ndual_mode A^bot\n+I IA\n-I -IA\nI+ AI\nI- -AI\n+Iinv I^-1A\n-Iinv -I^-1A\nIinv+ AI^-1\nIinv- -AI^-1\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.conj-Tuple{Mv}","page":"API","title":"Base.conj","text":"Clifford conjugate.\n\n(A)ǂ = A[:ǂ] equiv A^*dagger\n\nHint: type ǂ with \\doublepipe.\n\nIn literature the notation is usually A^ddagger, but \\ddagger is reserved by Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.exp-Tuple{Mv}","page":"API","title":"Base.exp","text":"Natural base exponential of X: e^X\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getindex-Tuple{Mv, Integer}","page":"API","title":"Base.getindex","text":"The i-th grade part.\n\nA[i] = A.grade(i) equiv langle A B^dagger rangle_i\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.inv-Tuple{Mv}","page":"API","title":"Base.inv","text":"Inverse.\n\n(A)⁻¹ = A^-1 = inv(A) = A.inv() equiv A^-1\n\nHint: type ⁻¹ with \\^-\\^1.\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.:×-Tuple{Mv, Mv}","page":"API","title":"GAlgebra.:×","text":"Cross product for vectors in 3D.\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.:∧-Tuple{Mv, Mv}","page":"API","title":"GAlgebra.:∧","text":"Wedge product.\n\nHint: type ∧ with \\wedge.\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.:≠-Tuple{Mv, Mv}","page":"API","title":"GAlgebra.:≠","text":"Comparisons of inequality.\n\nHint: Type ≠ with \\neq. Alternatively, use !=.\n\nA neq B equiv mathrmsimplify(A - B) neq 0\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.:⊙-Tuple{Mv, Mv}","page":"API","title":"GAlgebra.:⊙","text":"Anti-commutator product.\n\nHint: type ⊙ with \\odot. Alternatively, use <<.\n\nA bartimes B equiv dfrac12(AB+BA).\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.:⊛-Tuple{Mv, Mv}","page":"API","title":"GAlgebra.:⊛","text":"Scalar product.\n\nHint: type ⊛ with \\circledast. Alternatively, use %.\n\nA circledast B equiv langle A B^dagger rangle.\n\nIn literature the notation is usually ast , but it's visually indistinguishable from *.\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.:⊠-Tuple{Mv, Mv}","page":"API","title":"GAlgebra.:⊠","text":"Commutator product.\n\nHint: type ⊠ with \\boxtimes. Alternatively, use >>.\n\nA underlinetimes B equiv dfrac12(AB-BA).\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.:⋅-Tuple{Mv, Mv}","page":"API","title":"GAlgebra.:⋅","text":"Hestenes' inner product.\n\nHint: type ⋅ with \\cdot. Alternatively, use |.\n\nboldsymbolA_r cdot boldsymbolB_s equiv leftbeginarraylrr text  and  s neq 0   leftlangleboldsymbolA_r boldsymbolB_srightrangle_r-s  r text  or  s=0   0endarrayright\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.:⨼-Tuple{Mv, Mv}","page":"API","title":"GAlgebra.:⨼","text":"Left contraction, i.e. \"contraction onto\". \n\nHint: type ⨼ with \\intprod. Alternatively, use <.\n\nA rfloor B equiv sumlimits_r sleftlanglelangle Arangle_rlangle Brangle_srightrangle_s-r\n\nIn literature the notation is usually A rfloor B, but \\rfloor is reserved by Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.:⨽-Tuple{Mv, Mv}","page":"API","title":"GAlgebra.:⨽","text":"Right contraction, i.e. \"contraction by\".\n\nHint: type ⨽ with \\intprodr. Alternatively, use >.\n\nA lfloor B equiv sumlimits_r sleftlanglelangle Arangle_rlangle Brangle_srightrangle_r-s\n\nIn literature the notation is usually A lfloor B, but \\lfloor is reserved by Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.even-Tuple{Mv}","page":"API","title":"GAlgebra.even","text":"Even-grade part.\n\nA[:+] = (A)₊ = even(A) = A.even() equiv A_+\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.involute-Tuple{Mv}","page":"API","title":"GAlgebra.involute","text":"Grade involution.\n\n(A)ˣ = A[:*] = involute(A) equiv A_+ - A_- equiv A.even() - A.odd()\n\nHint: type ˣ with \\^x.\n\nIn literature the notation is usually A^*.\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.norm-Tuple{Mv}","page":"API","title":"GAlgebra.norm","text":"Norm.\n\nnorm(A) = A.norm() equiv leftlVert A rightrVert equiv sqrtA tildeA\n\nAlternatively:\n\nA.norm(hint=\"+\") equiv sqrtA tildeA\nA.norm(hint=\"-\") equiv sqrt- A tildeA\nA.norm(hint=\"0\") equiv sqrtleft A tildeA right\n\nOnly valid when the result is a scalar.\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.odd-Tuple{Mv}","page":"API","title":"GAlgebra.odd","text":"Odd-grade part.\n\nA[:-] = (A)₋ = odd(A) = A.odd() equiv A_-\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.proj-Tuple{Mv, Mv}","page":"API","title":"GAlgebra.proj","text":"Projection.\n\nproj(B, A) equiv P_B(A) equiv A.project_in_blade(B)\n\nOnly valid if B is a blade.\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.refl-Tuple{Mv, Mv}","page":"API","title":"GAlgebra.refl","text":"Reflection.\n\nrefl(B, A) equiv mathrmRefl_B(A) equiv A.reflect_in_blade(B)\n\nOnly valid if B is a blade.\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.rot-Tuple{Mv, Mv}","page":"API","title":"GAlgebra.rot","text":"Rotation.\n\nRotate the multivector A by the 2-blade itheta.\n\nrot(itheta, A) equiv A e^I theta equiv A.rotate_multivector(itheta)\n\n\n\n\n\n","category":"method"},{"location":"api/#GAlgebra.scalar-Tuple{Mv}","page":"API","title":"GAlgebra.scalar","text":"Scalar (grade-0) part.\n\nscalar(A) = A.scalar() equiv langle A B^dagger rangle equiv langle A B^dagger rangle_0\n\nNote: it returns a SymPy expression unlike A[0] which returns a Mv object\n\n\n\n\n\n","category":"method"},{"location":"#GAlgebra.jl","page":"Home","title":"GAlgebra.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia interface to GAlgebra, a symbolic Geometric Algebra/Calculus package for SymPy.","category":"page"},{"location":"#Development-Status","page":"Home","title":"Development Status","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Very early. But it already works and has many tests.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Build Status\n(Image: CI) (Image: )","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GAlgebra.jl itself doesn't depend on SymPy.jl, but is designed to work with it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"After installing SymPy.jl and GAlgebra.jl (see below for instructions), you may experiment with GAlgebra.jl just like in the Python version of GAlgebra (though there're some syntax differences between Python and Julia like True/true, '/\" etc.).","category":"page"},{"location":"","page":"Home","title":"Home","text":"For example, you may start with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"import SymPy: symbols, sympy, Sym\nusing GAlgebra\n\n# In console, uncomment to enable colored printing with ANSI escape sequences \n# galgebra.printer.Eprint()\n# In Jupyter, uncomment to enable LaTeX printing with MathJax\n# galgebra.printer.Format()\n\n(x, y, z) = xyz = symbols(\"x,y,z\",real=true)\no3d = galgebra.ga.Ga(\"e\", g=[1, 1, 1], coords=xyz)\n\nu = o3d.mv(\"u\", \"vector\")\nv = o3d.mv(\"v\", \"vector\")\nA = o3d.mv(\"A\", \"mv\")\nR = o3d.mv(\"R\", \"spinor\")\n# Volume element\nI = o3d.I()\n\n# Wedge product: ∧ \\wedge\nv ∧ A\n# Hestenes' inner product: ⋅ \\cdot\nv ⋅ A\n# Left contraction: ⨼ \\intprod\nv ⨼ A\n# Right contraction: ⨽ \\intprodr\nv ⨽ A\n# Scalar product: ⊛ \\circledast\n# A ⊛ B = <A B†>\nv ⊛ A\n# Commutator product: ⊠ \\boxtimes\n# A⊠B = (AB-BA)/2\nv ⊠ A\n# Anti-commutator product: ⊙ \\odot\n# A⊙B = (AB+BA)/2\nv ⊙ A\n\n# Norm: norm(A) = A.norm() := ||A||\nnorm(v)\n\n# Inverse: postfix ⁻¹ \\^-\\^1\n# (A)⁻¹ = A^-1 = inv(A) = A.inv()\n(R)⁻¹\nR^-1\ninv(R)\n\n# Reversion: ~A = rev(A) = A.rev()\n# A^† is usually used in literature\n~A\nrev(A)\n\n# Dual: postfix '\n# orthogonal complement, Λ^p -> Λ^(n-p)\n# note: Ga.dual_mode_value is default to \"I+\", so A' = A * I\n# change Ga.dual_mode_value to get a different definition\nA'\ndual(A)\n\n# Grade involution: postfix ˣ \\^x\n# (A)ˣ = A[:*] = involute(A) := A+ - A- = A.even() - A.odd()\n# A^* is usually used in literature\n(A)ˣ\ninvolute(A)\n\n# Clifford conjugate: postfix ǂ \\doublepipe\n# (A)ǂ = conj(A) := ((A)^*)^†\n(A)ǂ\nconj(A)\n\n# Projection: proj(B, A) = A.project_in_blade(B)\nproj(u, v)\n\n# Reflection: refl(B, A) = A.reflect_in_blade(B)\nrefl(u, v)\n\n# Rotation: rot(itheta, A) = A.rotate_multivector(itheta)\n# rotate the multivector A by the 2-blade itheta\nrot(u ∧ v, A)\n\n# Natural base exponential of x: e^x\nexp(u ∧ v)\n\n# Grade-i part: A[i] = A.grade(i) := <A>_i\nA[2]\n\n# Scalar (grade-0) part: scalar(A) = A.scalar() := <A> = <A>_0\n# note: it returns a SymPy expression unlike A[0] which returns a Mv object\nscalar(A)\n\n# Even-grade part: A[:+] = (A)₊ = even(A) = A.even() := A+\nA[:+]\neven(A)\n\n# Odd-grade part: A[:-] = (A)₋ = odd(A) = A.odd() := A-\nA[:-]\nodd(A)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: enter unicode symbols like ∧ with corresponding LaTeX commands like \\wedge by Tab completion which are provided in the comments.","category":"page"},{"location":"","page":"Home","title":"Home","text":"So far only galgebra.ga.Ga and galgebra.mv.Mv have been verified to work in Julia, see tests. The tests verified many identities in Linear Algebra and Geometric Algebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See examples of GAlgebra for more examples in Python. With some small changes, they can be ported to Julia.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode (you'll see a prompt like (v1.1) pkg>) and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"dev https://github.com/pygae/GAlgebra.jl.git","category":"page"},{"location":"","page":"Home","title":"Home","text":"The installation process will take a while, because it will install PyCall.jl and its dependencies and it will also use pip to install GAlgebra if you haven't. If you wish to use a version other than the latest released version of GAlgebra that will be installed by deps/build.jl, you can install that via pip before/after the installation of GAlgebra.jl, e.g. pip install -e <your local path to GAlgebra> or pip install https://github.com/pygae/galgebra/archive/master.zip.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now you may run GAlgebra.jl tests in Julia Pkg REPL mode: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"test GAlgebra","category":"page"},{"location":"","page":"Home","title":"Home","text":"At the first time it will take a while, because SymPy.jl is specified as a test dependency so it'll be installed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then you'll see something like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"   Testing GAlgebra\n Resolving package versions...\nTest Summary: | Pass  Broken  Total\nGAlgebra.jl   | 1289       1   1290\n   Testing GAlgebra tests passed","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hint: To get back to the Julia REPL please press backspace, see Pkg doc to learn more.","category":"page"}]
}
